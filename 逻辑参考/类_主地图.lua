--==============================================================================--
--q━━r┏━━rq━━rq━━rqqrrq━━r　qqrrq━━rqrqrq━━r
--┃q━s┃qr┃┃q━s┃qr┃┃　　┃┃q━s　┃　　┃┃qr┃┃ts┃┃q━s
--┃t━r┃┃┃┃┃┃qr┃ts┃┃┃┃┃┃t━r　┃┃┃┃┃ts┃┃　qs┃t━r
--┃q━s┃┃┃┃┃┃┃┃┃qr┃┃qr┃┃q━s　┃qr┃┃qr┃┃　tr┃q━s
--┃t━r┃ts┃┃ts┃┃┃┃┃┃┃┃┃┃t━r　┃┃┃┃┃┃┃┃┃qr┃┃t━r
--t━━s┗━━st━━ststststst━━s  tstststststst━━s
--
-- 作者:  创建:2010年6月4日8时16分42秒
--=============================================================================--

类_主地图  = class()





--=============================================================================--
-- ■ 构造函数
--=============================================================================--
function 类_主地图:初始化()

	self.地图名称 = ""
	self.地图_纹理组 = {}
	
	self.数据_第三层 = {}
	self.数据_第二层 = {}
	self.数据_地表层 = {}
	self.数据_最顶层 = {}
	
	
	self.矩形_障碍层 = {}
	self.地图_事件箱 = {}
	self.特效_最顶层 = {}
	
	self.地图_门点组 = {}
	
	self.清关 =  false 

--	self.怪物数量 = 0
--	self.怪物剩余数量 = 0
	
--	self.测试图片 = 引擎:载入图片("Dat/dnf_mapimg/家/light2.png")
--	self.测试精灵 = D2D_精灵.创建(self.测试图片,0,0,引擎:取图片宽度(self.测试图片),引擎:取图片高度(self.测试图片))
--	

--	
--	self.测试精灵:置混合模式(混合_颜色乘)
--	self.测试精灵.透明度 = 120
--	self.测试精灵.中间值 = 1

	self.关卡地图信息组 = {}

	self.地图宽度 = 0
	self.地图高度 = 0




	
	self.小地图_画面偏移 = {x=0,y=0}
	self.小地图_精灵 = D2D_精灵.创建(0,0,0,240,72)
	
	
	self.小地图_主角图片 =  引擎:载入图片("Dat/ui/小地图_主角.png")
	self.小地图_主角精灵 = D2D_精灵.创建(self.小地图_主角图片,0,0,6,12)
	self.小地图_主角精灵:置中心点(3,-15)
	
	self.小地图_NPC图片 =  引擎:载入图片("Dat/ui/小地图_NPC.png")
	self.小地图_NPC精灵 = D2D_精灵.创建(self.小地图_NPC图片,0,0,6,12)
	self.小地图_NPC精灵:置中心点(3,-15)
	

	self.小地图_怪物图片 =  引擎:载入图片("Dat/ui/小地图_怪物.png")
	self.小地图_怪物精灵 = D2D_精灵.创建(self.小地图_怪物图片,0,0,9,8)
	self.小地图_怪物精灵:置中心点(4,-17)
	
	
	

	


end




--=============================================================================--
-- ■ 更新sxxsss
--=============================================================================--
function 类_主地图:更新()


--	
--	
--	for n=1,table.getn(self.地图_门点组) do 
--		self.地图_门点组[n]:更新()
--	end 


	for n=1 ,table.getn(self.地图_事件箱) do 
	
		self.地图_事件箱[n].包围盒:置位置(self.地图_事件箱[n].x ,self.地图_事件箱[n].y) 
		
		if (self.地图_事件箱[n].包围盒:检测_点(Q_主角.坐标.x,Q_主角.坐标.y) ) then 
		
			if (self.地图_事件箱[n].map ~= nil) then 
				
				Q_主角.坐标.x = self.地图_事件箱[n].map_x
				Q_主角.坐标.y = self.地图_事件箱[n].map_y
				self:加载地图(self.地图_事件箱[n].map)
				
				break
			end 
			
		end 
	
	end 




	
	
	
	
	

end





--=============================================================================--
-- ■ 显示
--=============================================================================--
function 类_主地图:显示()


	for n=1,table.getn(self.数据_第三层) do
		if ( math.abs(Q_主角.坐标.x -  self.数据_第三层[n].显示x ) < Q_游戏数据.屏幕宽度 + 640 ) then
			self.数据_第三层[n].精灵:显示_高级(self.数据_第三层[n].显示x+Q_游戏数据.画面偏移.x  * 0.7 ,self.数据_第三层[n].显示y+Q_游戏数据.画面偏移.y,
			0,self.数据_第三层[n].翻转,1)
		end
	end

	for n=1,table.getn(self.数据_第二层) do
		if ( math.abs(Q_主角.坐标.x -  self.数据_第二层[n].显示x ) < Q_游戏数据.屏幕宽度 + 640 ) then
			self.数据_第二层[n].精灵:显示_高级(self.数据_第二层[n].显示x+Q_游戏数据.画面偏移.x  * 0.8  ,self.数据_第二层[n].显示y+Q_游戏数据.画面偏移.y,
			0,self.数据_第二层[n].翻转,1)
		end
	end


	for n=1,table.getn(self.数据_地表层) do
		
		if ( math.abs(Q_主角.坐标.x -  self.数据_地表层[n].显示x ) < Q_游戏数据.屏幕宽度 + 200 ) then
			
			self.数据_地表层[n].精灵:显示_高级(self.数据_地表层[n].显示x+Q_游戏数据.画面偏移.x   ,self.数据_地表层[n].显示y+Q_游戏数据.画面偏移.y,
			0,self.数据_地表层[n].翻转,1)
			
		end
		
	end
	
	
	
	
		
		
--	self.测试精灵.透明度 = self.测试精灵.透明度 + self.测试精灵.中间值
--	if (self.测试精灵.透明度 > 200 or self.测试精灵.透明度 < 120) then 
--		self.测试精灵.中间值 = - self.测试精灵.中间值
--	end 

--	self.测试精灵:置颜色(ARGB(self.测试精灵.透明度,255,255,255))
--	self.测试精灵:显示(330 +Q_游戏数据.画面偏移.x  ,338+Q_游戏数据.画面偏移.y)




end

--=============================================================================--
-- ■ 显示
--=============================================================================--
function 类_主地图:显示顶层()

	for n=1,table.getn(self.数据_最顶层) do
		if ( math.abs(Q_主角.坐标.x -  self.数据_最顶层[n].显示x ) < Q_游戏数据.屏幕宽度 + 200 ) then
			self.数据_最顶层[n].精灵:显示_高级(self.数据_最顶层[n].显示x+Q_游戏数据.画面偏移.x   ,self.数据_最顶层[n].显示y+Q_游戏数据.画面偏移.y,
			0,self.数据_最顶层[n].翻转,1)
		end
	end
	
	for n=1,table.getn(self.特效_最顶层) do 
		self.特效_最顶层[n]:显示()
	end 


	for n=1,table.getn(self.矩形_障碍层) do
		self.矩形_障碍层[n].包围盒:置位置(self.矩形_障碍层[n].x+Q_游戏数据.画面偏移.x,self.矩形_障碍层[n].y+Q_游戏数据.画面偏移.y)
		if(Q_调试)then
			self.矩形_障碍层[n].包围盒:显示()
		end 
	end


	if (Q_调试) then 

		
		for n=1 ,table.getn(self.地图_事件箱) do 
			self.地图_事件箱[n].包围盒:置颜色(颜色_红)
			self.地图_事件箱[n].包围盒:置位置(self.地图_事件箱[n].x + Q_游戏数据.画面偏移.x,self.地图_事件箱[n].y + Q_游戏数据.画面偏移.y) 
			self.地图_事件箱[n].包围盒:显示()
		end 
		
	end 




end


--=============================================================================--
-- ■ 显示小地图
--=============================================================================--
function 类_主地图:显示小地图(x,y)


	self.小地图_画面偏移.x , self.小地图_画面偏移.y  = 引擎:取画面坐标(Q_主角.坐标.x * 0.15, Q_主角.坐标.y * 0.15, 
														self.小地图_宽度, self.小地图_高度,160,66)
	
	self.小地图_精灵:置显示区域(取整(-self.小地图_画面偏移.x),取整(-self.小地图_画面偏移.y)-8,162,68)
	self.小地图_精灵:显示(x,y)
	


	for n=#Q_屏幕.屏幕NPC组,1,-1 do 
		
		if ( math.abs(Q_主角.坐标.x -  Q_屏幕.屏幕NPC组[n].坐标.x  ) < Q_游戏数据.屏幕宽度*0.8)then
			
			self.小地图_NPC精灵:显示(477+ math.ceil(Q_屏幕.屏幕NPC组[n].坐标.x * 0.15 + self.小地图_画面偏移.x),math.ceil(Q_屏幕.屏幕NPC组[n].坐标.y * 0.15 + self.小地图_画面偏移.y))
			
		end
		
	end
	


	self.小地图_主角精灵:显示(477+ math.ceil(Q_主角.坐标.x * 0.15 + self.小地图_画面偏移.x),math.ceil(Q_主角.坐标.y * 0.15 + self.小地图_画面偏移.y))
	
	

	
	for n=#Q_屏幕.屏幕怪物组,1,-1 do 
		
		if (Q_屏幕.屏幕怪物组[n].已经消失  or  ( math.abs(Q_主角.坐标.x -  Q_屏幕.屏幕怪物组[n].坐标.x  ) > Q_游戏数据.屏幕宽度*0.8) ) then
			
		else
			self.小地图_怪物精灵:显示(477+ math.ceil(Q_屏幕.屏幕怪物组[n].坐标.x * 0.15 + self.小地图_画面偏移.x),math.ceil(Q_屏幕.屏幕怪物组[n].坐标.y * 0.15 + self.小地图_画面偏移.y))
		end
		

	end 
	

	
--	for n=1,table.getn(Q_网络玩家组) do 
--	
--		if (Q_网络玩家组[n].坐标.x * self.W偏移 + self.小地图_画面偏移.x > 1
--			and Q_网络玩家组[n].坐标.y * self.H偏移  + self.小地图_画面偏移.y < 100 
--			and Q_网络玩家组[n].坐标.y * self.H偏移  + self.小地图_画面偏移.y  > 5 ) then
--	
--			self.小地图_角色_精灵:显示(取整( 533 + Q_网络玩家组[n].坐标.x * self.W偏移  + self.小地图_画面偏移.x) ,取整(Q_网络玩家组[n].坐标.y * self.H偏移 + self.小地图_画面偏移.y + 5),0,1,1 )
--		end

--	end 
--	









end




---=============================================================================--
-- ■ 清理旧地图数据()
--=============================================================================--

function 类_主地图:清理旧地图数据()
	
	
	for n=#self.地图_纹理组,1,-1 do 
		引擎:销毁图片(self.地图_纹理组[n].图片)
	end 
	
	for n=#self.数据_第三层,1,-1 do
		self.数据_第三层[n].精灵:销毁()
	end

	for n=#self.数据_第二层,1,-1 do
		self.数据_第二层[n].精灵:销毁()
	end

	for n=#self.数据_地表层,1,-1 do
		self.数据_地表层[n].精灵:销毁()
	end

	for n=#self.数据_最顶层,1,-1 do
		self.数据_最顶层[n].精灵:销毁()
	end
	
	for n=#self.特效_最顶层,1,-1 do
		self.特效_最顶层[n]:销毁()
	end
	


	for n=#Q_屏幕.屏幕物件组,1,-1 do 
	
		if ( Q_屏幕.屏幕物件组[n].标识类型 == "屏幕特效" or   Q_屏幕.屏幕物件组[n].标识类型 == "地面掉落物" or   Q_屏幕.屏幕物件组[n].标识类型 == "地图物件" 
			or   Q_屏幕.屏幕物件组[n].标识类型 == "游戏NPC"  or   Q_屏幕.屏幕物件组[n].标识类型 == "怪物_普通"  or   Q_屏幕.屏幕物件组[n].标识类型 == "特效_物理行为"   ) then
			
			
			
			--Q_屏幕.屏幕物件组[n]:销毁()
			table.remove(Q_屏幕.屏幕物件组,n,1)
			
		end
		
	end 
	
	
	for n=table.getn(Q_屏幕.屏幕怪物组),1,-1 do 
		Q_屏幕.屏幕怪物组[n]:销毁()
	end 
	
	for n=table.getn(Q_屏幕.屏幕特效组),1,-1 do 
		Q_屏幕.屏幕特效组[n]:销毁()
	end 

	for n=table.getn(Q_屏幕.地面物品组),1,-1 do 
		Q_屏幕.地面物品组[n]:销毁()
	end 
	
	
	for n=table.getn(Q_屏幕.地图物件组),1,-1 do 
		Q_屏幕.地图物件组[n]:销毁()
	end 
	
	for n=table.getn(Q_屏幕.屏幕NPC组),1,-1 do 
		Q_屏幕.屏幕NPC组[n]:销毁()
	end 
	
	
	self.数据_地表层 = {}
	self.数据_最顶层 = {}
	self.特效_最顶层 = {}
	self.地图_纹理组 = {}
	self.数据_第三层 = {}
	self.数据_第二层 = {}
	self.地图_事件箱 = {}
	self.矩形_障碍层 = {}
	
	Q_屏幕.屏幕怪物组 = {}
	Q_屏幕.屏幕特效组 = {}
	Q_屏幕.地面物品组 = {}
	Q_屏幕.地图物件组 = {}
	Q_屏幕.屏幕NPC组 = {}
	
	
	Q_屏幕.顶部动态血条.可视 = false
	
	
end 


---=============================================================================--
-- ■ 加载地图()
--=============================================================================--

function 类_主地图:加载地图(地图名称)

	local 地图文件 =  "Dat/map/" .. 地图名称 .. ".emhmap"
	--local 地图脚本 =  "Dat/map/" .. 地图名称 .. ".sc"

	if(文件是否存在(地图文件) == false) then
		调试输出("没有找到地图文件")
		return
	end
	
	
	if(文件是否存在("Dat/map/" .. 地图名称 .. ".jpg") ) then
		self.小地图图片 = 取图片缓存纹理("Dat/map/" .. 地图名称 .. ".jpg")
		self.小地图_精灵:置图片(self.小地图图片)
		self.小地图_宽度 = 引擎:取图片宽度(self.小地图图片)
		self.小地图_高度 = 引擎:取图片高度(self.小地图图片)
		self.小地图_精灵:置颜色(ARGB(220,255,255,255))
	else
		self.小地图_精灵:置颜色(颜色_黑)
	end
	
	self.地图名称 = 地图名称

	
	

	self:清理旧地图数据()
	   
	local 文件号 = assert(io.open(地图文件, "r"))
	local 全部文本 = 文件号:read("*all")
	文件号:close()
	
	local  首次分割 = 分割文本(全部文本, "*") 
	local  分割成员数 = table.getn(首次分割)

	
	if (  分割成员数 > 0 ) then 
		self:读地图基本数据(首次分割[1])
	end 
	
	if (  分割成员数 > 1 ) then 
		self:读地图基础层数据(self.数据_第三层,首次分割[2])
	end 
	
	if (  分割成员数 > 2 ) then 
		self:读地图基础层数据(self.数据_第二层,首次分割[3])
	end 
	
	if (  分割成员数 > 3 ) then 
		self:读地图基础层数据(self.数据_地表层,首次分割[4])
	end 
	
	if (  分割成员数 > 4 ) then 
		self:读地图物件层数据(首次分割[5])
	end 
	
	if (  分割成员数 > 5 ) then 
			
		self:读地图基础层数据(self.数据_最顶层,首次分割[6])
	end 
	
	if (  分割成员数 > 6 ) then 
		self:读地图障碍矩形层数据(首次分割[7])
	end 
	
	if (  分割成员数 > 7 ) then 
		self:读地图怪物配置数据(首次分割[8])
	end 
	

	
	
	
	if ( Q_地图脚本组[地图名称] ~= nil ) then
		Q_地图脚本组[地图名称].Main()
	end
	

	for n=1 ,table.getn(self.地图_事件箱) do 
		self.地图_事件箱[n].包围盒 = D2D_包围盒.创建(self.地图_事件箱[n].x,self.地图_事件箱[n].y,self.地图_事件箱[n].w,self.地图_事件箱[n].h)
	end 
	
	
	
	
	Q_游戏数据.屏幕遮罩时间 = 200
	

	Q_主角:停止()



	
--	Q_主角.状态 = "静止"
--	Q_主角.跳跃攻击 = false 
--	


--	Q_屏幕遮罩时间 =150
--	Q_游戏进度 = "游戏开始" 
--	
--	
--	
--	if(文件是否存在(地图脚本 )) then
--	
--		local f = assert(io.open(地图脚本, "r"))
--		local t = f:read("*all")
--		f:close()
--		执行脚本_文本(t)
--		
--	end
--	


--	
--	
--	if ( Q_背景音乐名称 ~= Q_地图配置.音乐 ) then 
--	
--		if ( Q_背景音乐名称 ~= "" ) then 
--		
--			背景音效:销毁()
--		end 
--		
--		背景音效 = D2D_音效.创建("Dat/music/" .. Q_地图配置.音乐)
--		背景音效:播放_高级(Q_地图配置.音量,true)
--		Q_背景音乐名称 =  Q_地图配置.音乐
--	
--	end 
--	
--	
--	if ( Q_地图配置.地面 == "草地" ) then 
--		Q_主角.脚步声 = true 
--	else 
--		Q_主角.脚步声 = false
--	end
--	
--	
--	Q_游戏数据.画面偏移.x ,Q_游戏数据.画面偏移.y = 引擎:取画面坐标(Q_主角.坐标.x,Q_主角.坐标.y,Q_地图宽度,Q_地图高度,640,480)
--		
--	--调试输出(table.getn(Q_屏幕物件组))
--	
--	
--	self:更新关卡地图信息()
--	
--	if (Q_地图配置.类型 == "地下城") then 
--		Q_小地图.地下城模式 = true 
--	else 
--		Q_小地图.地下城模式 = false 
--	end 
	
	
	
	

--	
--	MSG("[系统]","进入地图：" .. 地图名称  ,颜色_银)
--	
	
end 


---=============================================================================--
-- ■ 更新关卡地图信息()
--=============================================================================--

function 类_主地图:更新关卡地图信息()


--	if ( Q_地图配置.类型 == "地下城") then 
--		self.怪物数量 = table.getn(Q_屏幕怪物组)
--		self.怪物剩余数量 = self.怪物数量 
--		Q_地图.关卡地图信息组[Q_地图配置.标识].格子:激活(573,60,true)
--		self.清关 =  Q_地图.关卡地图信息组[Q_地图配置.标识].清关 
--	end 
--	

	
	
	
	
	
end 


---=============================================================================--
-- ■ 取缓存纹理(标识)
--=============================================================================--

function 类_主地图:取缓存纹理(标识)
	
	local 临时逻辑值 = false 
	
	for n=1, table.getn(self.地图_纹理组 ) do
		if ( self.地图_纹理组 [n].文件标识 == 标识 )  then
			return self.地图_纹理组 [n].图片
		end
	end
	
	
	local 临时纹理 = {文件标识 = 标识,
					 图片 = 引擎:载入图片( 标识) }
					 
	table.insert(self.地图_纹理组,临时纹理)

	return 临时纹理.图片

end 







---=============================================================================--
-- ■ 加载地图()
--=============================================================================--

function 类_主地图:读地图基本数据(文本数据)
	
	local  文本分组 = 分割文本(文本数据, "|")
	
	if ( table.getn(文本分组) == 1 ) then 
	
		local 再分割文本组 = 分割文本 (文本分组[1],",")
		
		if ( table.getn(再分割文本组) == 2 ) then 
		
			self.地图宽度 = tonumber(再分割文本组[1])
			self.地图高度 = tonumber(再分割文本组[2])
			

			
		end 
		
	end 

end 


---=============================================================================--
-- ■ 读地图基础层数据()
--=============================================================================--

function 类_主地图:读地图基础层数据(层次,文本数据)
	
	local  文本分组 = 分割文本(文本数据, "|")
	local 临时图片 = 0
	local 元素数量= table.getn(文本分组)
		
	
	for n=1,元素数量 do
		local 再分割文本组 = 分割文本 (文本分组[n],",")
		
		if ( table.getn(再分割文本组) == 4 ) then 
			层次[n]= {
				显示x= tonumber (再分割文本组 [1]),
				显示y= tonumber (再分割文本组 [2]),
				图片文件 =  再分割文本组 [3],
				翻转 = tonumber (再分割文本组 [4])	
			}
			
			if ( 再分割文本组 [3] ~=  "" ) then 
				临时图片 = self:取缓存纹理(再分割文本组 [3])
				层次[n].精灵 = D2D_精灵.创建(临时图片,0,0,引擎:取图片宽度(临时图片),引擎:取图片高度(临时图片))
				层次[n].精灵:置中心点(取整( 引擎:取图片宽度(临时图片)/2 ), 取整(引擎:取图片高度(临时图片)/2))
			end 
		
		
		end
	end
end 




---=============================================================================--
-- ■ 读地图物件层数据()
--=============================================================================--

function 类_主地图:读地图物件层数据(文本数据)
	

	local  文本分组 = 分割文本(文本数据, "|")
	local 物件数量 =  table.getn (文本分组)
	local 临时物件信息 = {}
	
	for n=1,物件数量  do 
	
		local 再分割文本组 = 分割文本 (文本分组[n],",")
		
		if ( table.getn(再分割文本组) == 7 ) then 
						
			临时物件信息 = {
				显示x= tonumber (再分割文本组 [1]),
				显示y= tonumber (再分割文本组 [2]),
				图片文件 =  再分割文本组 [3],
				翻转 = tonumber (再分割文本组 [4]),
				中心点偏移_x =  tonumber (再分割文本组 [5]),
				中心点偏移_y =  tonumber (再分割文本组 [6]),
				中心点_x = tonumber (再分割文本组 [1]) + tonumber (再分割文本组 [5]),
				中心点_y =  tonumber (再分割文本组 [2]) + tonumber (再分割文本组 [6]),
				自动透明 =   tonumber (再分割文本组 [7])
			}


			if ( 临时物件信息.图片文件 ~=  "" ) then 
				local 临时图片 = self:取缓存纹理(临时物件信息.图片文件)
				local 临时物件 = 地图物件.创建(临时物件信息,临时图片,n)
				
				table.insert(Q_屏幕.地图物件组,临时物件)
				Q_屏幕:增加屏幕物件(临时物件)
				
			end 

				
		end 
		
	
	end 



end 


---=============================================================================--
-- ■ 读地图障碍矩形层数据()
--=============================================================================--

function 类_主地图:读地图障碍矩形层数据(文本数据)
	
	
	local  文本分组 = 分割文本(文本数据, "|")
	local 临时图片 = 0
	local 元素数量= table.getn(文本分组)
		
	
	for n=1,元素数量 do
		local 再分割文本组 = 分割文本 (文本分组[n],",")
		
		if ( table.getn(再分割文本组) == 5 ) then 

			self.矩形_障碍层 [n]  = {
				x = tonumber (再分割文本组 [1]),
				y =tonumber (再分割文本组 [2]),
				w =tonumber (再分割文本组 [3]),
				h =tonumber (再分割文本组 [4]),
				类型 = tonumber (再分割文本组 [5]),
				包围盒 = D2D_包围盒.创建(tonumber (再分割文本组 [1]),tonumber (再分割文本组 [2]),tonumber (再分割文本组 [3]),tonumber (再分割文本组 [4]))
			}
			
			if (self.矩形_障碍层 [n].类型==1) then 
				self.矩形_障碍层[n].包围盒:置颜色(颜色_黄)
			else 
				self.矩形_障碍层[n].包围盒:置颜色(颜色_蓝)
			end 
			
			
			
		
		end
	end	
	
	
end 




---=============================================================================--
-- ■ 读地图怪物配置数据()
--=============================================================================--

function 类_主地图:读地图怪物配置数据(文本数据)

	local  文本分组 = 分割文本(文本数据, "|")
	local 元素数量= table.getn(文本分组)
	local 坐标x = 0
	local 坐标y = 0
	local 名称 = ""
	
	for n=1,元素数量 do
		
		local 再分割文本组 = 分割文本 (文本分组[n],",")
		
		if ( table.getn(再分割文本组) == 3 ) then 
			
			坐标x =  tonumber (再分割文本组 [1])
			坐标y =  tonumber (再分割文本组 [2])
			名称 =   再分割文本组 [3]
			
			
			Q_系统:增加怪物(坐标x,坐标y,名称)
		end
		
	end

end





--=============================================================================--
-- ■ 是否可行
--=============================================================================--
function 类_主地图:是否可行(x,y)
	
	for n=1 , #Q_地图.矩形_障碍层  do
		
		if(Q_地图.矩形_障碍层[n].包围盒:检测_点(x + Q_游戏数据.画面偏移.x,y ) ) then -- 接触到包围盒
			return false
		end
		
	end
	
	return  true


end






--=============================================================================--
-- ■ 销毁
--=============================================================================--
function 类_主地图:销毁()



	for n=1,table.getn(self.地图_纹理组) do 
		引擎:销毁图片(self.地图_纹理组[n].图片)
	end 
	
	for n=1,table.getn(self.数据_第三层) do
		self.数据_第三层[n].精灵:销毁()
	end

	for n=1,table.getn(self.数据_第二层) do
		self.数据_第二层[n].精灵:销毁()
	end

	for n=1,table.getn(self.数据_地表层) do
		self.数据_地表层[n].精灵:销毁()
	end

	for n=1,table.getn(self.数据_最顶层) do
		self.数据_最顶层[n].精灵:销毁()
	end
	
	for n=1,table.getn(self.特效_最顶层) do
		self.特效_最顶层[n]:销毁()
	end
	

	self.地图_纹理组 = nil
	self.数据_第三层 = nil
	self.数据_第二层 = nil
	self.数据_地表层 = nil
	self.矩形_障碍层 = nil
	self.地图_事件箱 = nil
	self.数据_最顶层 = nil
	self.特效_最顶层 = nil
	self.地图_门点组 = nil
	
	
	self.地图_纹理组 = {}
	self.数据_第三层 = {}
	self.数据_第二层 = {}
	self.数据_地表层 = {}
	self.矩形_障碍层 = {}
	self.地图_事件箱 = {}
	self.数据_最顶层 = {}
	self.特效_最顶层 = {}
	self.地图_门点组 = {}
	
	
	
end 





